# プロジェクト再構築リファクタ 要件書

## 背景と目的
- 現在のプロジェクトは `MonoBehaviour` にゲームルール、進行管理、UI更新、生成処理が集約されやすく、単一クラスの責務が肥大化している。
- `PlayerController`、`GameManager`、`EnemySpawner`、各UIコントローラーがシングルトンや静的イベントに依存しており、変更時の影響範囲と依存関係の追跡コストが高い。
- 今後の機能追加、仕様変更、テスト追加を容易にするため、ゲームルールを純C#へ分離し、Unity依存コードを薄いアダプター層へ整理する。
- 本リファクタの目的は、ゲーム挙動を維持しながら、責務分離されたアーキテクチャへ段階的に移行できる基盤を定義することである。

## スコープ内
- 現在の主要システムを対象に、責務分離された新アーキテクチャ方針を定義する。
- `Domain`、`Application`、`Infrastructure`、`Presentation` の4層構成へ再編する。
- プレイヤー進行、戦闘、敵生成、UI表示、入力、データ定義の責務境界を明確化する。
- シングルトン依存とグローバル静的イベント依存を段階的に削減するための移行前提を定義する。
- 既存の主要フロー（移動、攻撃、経験値、レベルアップ、スタイル変更、敵スポーン、HUD更新）を新構成へ移設する際の要件を整理する。
- EditMode テストを中心とした検証しやすい構造へ移行するための前提を定義する。

## スコープ外
- 新規ゲームルール追加、バランス調整、演出強化は本リファクタの主目的に含めない。
- UIデザインやUXの全面刷新は対象外とする。必要最小限の責務分離に伴う変更のみ対象とする。
- DOTS/ECS への全面移行は対象外とする。
- セーブ/ロード、マルチプレイ、アセットバンドル対応など未実装の拡張機能は対象外とする。
- すべての既存クラスを一度に置換するビッグバン移行は行わない。

## 機能要件

### 1. アーキテクチャ再編
- スクリプトは少なくとも以下の責務単位で再編できること。
  - `Domain`: ゲームルール、状態、計算、判定
  - `Application`: ユースケース、進行制御、状態更新オーケストレーション
  - `Infrastructure`: Unity依存処理、Prefab生成、Input System、アセット解決
  - `Presentation`: UI表示、画面イベント受け渡し、ビュー同期
- `MonoBehaviour` は Unityイベント受信、シーン参照保持、描画反映、物理同期に責務を限定できること。

### 2. プレイヤー進行の分離
- プレイヤーのHP、経験値、レベル、移動速度補正、スタイル効果、武器状態は純C#の状態モデルとして表現できること。
- `PlayerController` 相当の既存責務は、入力受付、見た目反映、状態同期に分解できること。
- スタイル変更や武器アップグレードは、UIクラスから直接ロジックを持たず、Application層の操作として実行できること。

### 3. ゲーム進行管理の分離
- 制限時間、ゲームクリア、ゲームオーバーなどの進行状態は、`GameManager` から独立した進行管理コンポーネントまたはサービスで管理できること。
- 時間経過に応じた更新処理は、`Update` 直書きではなく、テスト可能な進行更新ロジックへ分離できること。

### 4. 敵生成と戦闘処理の分離
- 敵スポーン間隔、スポーン位置決定、ターゲット設定、敵検索などのロジックは、生成制御と Unity生成処理を分離できること。
- 武器や弾の挙動は、発射判定と生成/表示を分離できること。
- 現在の挙動を保つため、既存の敵探索やスポーン条件を再現可能な構造とすること。

### 5. UI責務の分離
- UIクラスは画面描画と入力通知に責務を限定し、ゲームルールや状態更新の主体にならないこと。
- HUD表示は、状態取得先が直接シングルトン参照や `FindFirstObjectByType` に依存しない構成へ移行できること。
- UI Toolkit の UXML/USS と、表示更新ロジックを疎結合に保てること。

### 6. データ駆動化
- プレイヤー、敵、武器、スタイルなどの設定値は `ScriptableObject` などのデータ定義に集約し、ロジックから直接ハードコードしないこと。
- `enum + switch` ベースの分岐は、定義データまたは登録テーブルで差し替え可能な構成へ移行できること。

### 7. 依存解決と初期化
- シーン開始時に依存関係を組み立てる初期化ポイントを明確にすること。
- 新構成では `Instance` を前提にした参照取得を新規追加しないこと。
- 将来的な差し替えやテストのため、依存対象は明示的に注入または組み立てできること。

### 8. テスト容易性
- レベルアップ、経験値加算、スタイル効果、ゲーム進行、スポーン判定などの主要ロジックは EditMode テスト対象として分離できること。
- Unityランタイムがなくても検証可能なロジックを優先して純C#化すること。

## 非機能要件
- 既存のゲームプレイ挙動を大きく崩さないこと。リファクタは機能追加ではなく保守性改善を主目的とする。
- 既存シーンやアセット参照を一度に全面変更せず、段階的に移行できる構成とすること。
- 各層の責務境界がコードレビュー時に判断できる程度に明確であること。
- 主要クラスは単一責務を維持し、再び巨大化しないように役割を限定すること。
- 命名、フォルダ構成、データ配置を統一し、追加機能が同じルールで実装できること。
- 現行の Input System を継続利用すること。
- C# コーディングスタイルは既存プロジェクト規約に従うこと。

## 受け入れ条件
- 新アーキテクチャの責務分割方針がドキュメント上で明確に定義されている。
- 主要な既存責務（プレイヤー、ゲーム進行、敵生成、UI、データ定義）について、どの層へ移すか判断できる。
- 今後の実装計画で、どのクラスを段階的に置き換えるかを具体化できる状態になっている。
- `plan.md` と `todo.md` を作成するために必要な前提が、この要件書だけで追える。
- 既存挙動維持、段階移行、テスト容易性の3点が要件として明文化されている。

## 未確定事項・確認事項
- DIコンテナは導入せず手動組み立てを前提とするか、軽量な依存解決基盤を導入するか。
- `ScriptableObject` を設定データ専用に制限する範囲をどこまで厳密にするか。
- 武器・敵挙動の一部を将来的に ECS 化する前提を、今回の境界設計にどこまで織り込むか。
- リファクタの初期対象を「プレイヤー進行優先」にするか、「ゲーム進行基盤優先」にするか。
- PlayMode テストの導入範囲を、UI連携まで含めるか、純ロジック中心に留めるか。
