# GameEventsのような疎結合イベントシステムのメリット

ここでは **GameEvents** のような疎結合なイベントシステムについて、具体例を交えて整理します。

---

## 従来の密結合な実装 vs イベントシステム

### 例1: プレイヤーがダメージを受けた時の処理

### ❌ 密結合な実装（Before）

```csharp
public class PlayerController : MonoBehaviour
{
    void TakeDamage(int damage)
    {
        _currentHp -= damage;
        
        // UIを更新
        HealthUI.Instance.UpdateHealth(_currentHp);
        
        // サウンドを再生
        SoundManager.Instance.PlayDamageSound();
        
        // パーティクルを表示
        EffectManager.Instance.ShowDamageEffect(transform.position);
        
        // カメラを揺らす
        CameraShake.Instance.Shake(0.2f);
        
        // アチーブメントをチェック
        AchievementManager.Instance.CheckDamageTaken();
    }
}
```

#### 問題点

* PlayerControllerが複数のシステムを知っている必要がある
* 新機能追加のたびにPlayerControllerを修正する必要がある
* テストが困難（すべての依存を用意する必要がある）
* 各システムがシングルトン前提になりやすい

---

### ✅ イベントシステム（After）

```csharp
public class PlayerController : MonoBehaviour
{
    void TakeDamage(int damage)
    {
        _currentHp -= damage;
        
        // イベントを発火するだけ
        GameEvents.RaisePlayerDamaged(damage);
    }
}
```

```csharp
// 各システムは独立して動作
public class HealthUI : MonoBehaviour
{
    void OnEnable() => GameEvents.OnPlayerDamaged += UpdateHealth;
    void OnDisable() => GameEvents.OnPlayerDamaged -= UpdateHealth;
    void UpdateHealth(int damage) { /* UI更新 */ }
}
```

```csharp
public class SoundManager : MonoBehaviour
{
    void OnEnable() => GameEvents.OnPlayerDamaged += PlayDamageSound;
    void OnDisable() => GameEvents.OnPlayerDamaged -= PlayDamageSound;
    void PlayDamageSound(int damage) { /* サウンド再生 */ }
}
```

#### メリット

* PlayerControllerは他のシステムを知らなくてよい
* 新機能追加時にPlayerControllerを変更不要
* 各システムを独立してテスト可能
* シングルトンが不要になる

---

## 具体的なメリット

### 1. 機能追加が簡単

#### ❌ 密結合の場合

```csharp
public class PlayerController : MonoBehaviour
{
    void TakeDamage(int damage)
    {
        _currentHp -= damage;
        HealthUI.Instance.UpdateHealth(_currentHp);
        SoundManager.Instance.PlayDamageSound();
        
        // 新機能追加のたびに修正が必要
        ComboSystem.Instance.ResetCombo();
    }
}
```

#### ✅ イベントシステムの場合

```csharp
public class ComboSystem : MonoBehaviour
{
    void OnEnable() => GameEvents.OnPlayerDamaged += ResetCombo;
    void OnDisable() => GameEvents.OnPlayerDamaged -= ResetCombo;
    void ResetCombo(int damage) { /* コンボリセット */ }
}
```

* PlayerControllerは一切変更不要

---

### 2. 機能のON / OFFが簡単

```csharp
public class TutorialManager : MonoBehaviour
{
    [SerializeField] GameObject _soundManager;
    [SerializeField] GameObject _effectManager;
    
    void StartTutorial()
    {
        // チュートリアル中はサウンドとエフェクトを無効化
        _soundManager.SetActive(false);
        _effectManager.SetActive(false);
        // OnDisableでイベント購読が自動解除される
    }
}
```

---

### 3. デバッグが簡単

```csharp
public class EventDebugger : MonoBehaviour
{
    void OnEnable()
    {
        GameEvents.OnPlayerDamaged += damage =>
            Debug.Log($"[Event] PlayerDamaged: {damage}");
        
        GameEvents.OnEnemyDied += enemy =>
            Debug.Log($"[Event] EnemyDied: {enemy.name}");
    }
}
```

---

### 4. テストが簡単

#### ❌ 密結合

```csharp
[Test]
public void TestPlayerTakeDamage()
{
    var mockUI = CreateMockUI();
    var mockSound = CreateMockSound();
    var mockEffect = CreateMockEffect();
    // セットアップが大変
}
```

#### ✅ イベントシステム

```csharp
[Test]
public void TestPlayerTakeDamage()
{
    bool eventFired = false;
    GameEvents.OnPlayerDamaged += damage => eventFired = true;
    
    player.TakeDamage(10);
    
    Assert.IsTrue(eventFired);
}
```

---

## 実際のゲーム開発での例

### アチーブメントシステムの追加

```csharp
public class AchievementSystem : MonoBehaviour
{
    int _enemiesKilled;
    int _damageTaken;
    
    void OnEnable()
    {
        GameEvents.OnEnemyDied += OnEnemyKilled;
        GameEvents.OnPlayerDamaged += OnPlayerDamaged;
    }
    
    void OnDisable()
    {
        GameEvents.OnEnemyDied -= OnEnemyKilled;
        GameEvents.OnPlayerDamaged -= OnPlayerDamaged;
    }
    
    void OnEnemyKilled(GameObject enemy)
    {
        _enemiesKilled++;
        if (_enemiesKilled >= 100)
            UnlockAchievement("Enemy Hunter");
    }
    
    void OnPlayerDamaged(int damage)
    {
        _damageTaken++;
        if (_damageTaken == 0)
            UnlockAchievement("Perfect");
    }
}
```

---

### マルチプレイヤー対応

```csharp
public class NetworkSync : MonoBehaviour
{
    void OnEnable()
    {
        GameEvents.OnPlayerMoved += SyncPosition;
        GameEvents.OnEnemyDied += SyncEnemyDeath;
    }
    
    void SyncPosition(Vector3 position)
    {
        NetworkManager.SendPosition(position);
    }
    
    void SyncEnemyDeath(GameObject enemy)
    {
        NetworkManager.SendEnemyDeath(enemy.GetInstanceID());
    }
}
```

---

## 注意点とベストプラクティス

### 1. イベントの粒度

❌ 悪い例

```csharp
GameEvents.OnPlayerMovedLeft;
GameEvents.OnPlayerMovedRight;
GameEvents.OnPlayerMovedUp;
GameEvents.OnPlayerMovedDown;
```

✅ 良い例

```csharp
GameEvents.OnPlayerMoved; // 方向は引数で渡す
```

---

### 2. パフォーマンス

❌ 毎フレーム発火

```csharp
void Update()
{
    GameEvents.RaisePlayerMoved(transform.position);
}
```

✅ 必要なときだけ発火

```csharp
void Update()
{
    if (_moveInput != Vector2.zero)
    {
        GameEvents.RaisePlayerMoved(transform.position);
    }
}
```

---

### 3. メモリリーク防止

❌ 購読解除を忘れる

```csharp
void Start()
{
    GameEvents.OnPlayerDied += HandleDeath;
}
```

✅ 必ず解除する

```csharp
void OnEnable()
{
    GameEvents.OnPlayerDied += HandleDeath;
}

void OnDisable()
{
    GameEvents.OnPlayerDied -= HandleDeath;
}
```

---

## まとめ

### イベントシステムが特に有効な場面

* 複数のシステムが同じイベントに反応する場合
* 後から機能追加する可能性が高い場合
* 機能のON / OFFを動的に切り替えたい場合
* テストのしやすさを重視する場合

### 使わない方が良い場面

* 1対1の直接的な関係
* 同一GameObject内のコンポーネント間通信
* 毎フレーム実行される高頻度処理
* 大量のオブジェクトが関わる処理

---

イベントシステムは「**知る必要のないものは知らない**」という原則を実現する強力な道具です。適切に使えば、保守性と拡張性はぐっと伸びます。
